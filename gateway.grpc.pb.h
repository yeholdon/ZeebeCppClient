// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: gateway.proto
#ifndef GRPC_gateway_2eproto__INCLUDED
#define GRPC_gateway_2eproto__INCLUDED

#include "gateway.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace gateway_protocol {

class Gateway final {
 public:
  static constexpr char const* service_full_name() {
    return "gateway_protocol.Gateway";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //
    // Iterates through all known partitions round-robin and activates up to the requested
    // maximum and streams them back to the client as they are activated.
    //
    // Errors:
    // INVALID_ARGUMENT:
    // - type is blank (empty string, null)
    // - worker is blank (empty string, null)
    // - timeout less than 1
    // - maxJobsToActivate is less than 1
    std::unique_ptr< ::grpc::ClientReaderInterface< ::gateway_protocol::ActivateJobsResponse>> ActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::gateway_protocol::ActivateJobsResponse>>(ActivateJobsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::gateway_protocol::ActivateJobsResponse>> AsyncActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::gateway_protocol::ActivateJobsResponse>>(AsyncActivateJobsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::gateway_protocol::ActivateJobsResponse>> PrepareAsyncActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::gateway_protocol::ActivateJobsResponse>>(PrepareAsyncActivateJobsRaw(context, request, cq));
    }
    //
    // Cancels a running process instance
    //
    // Errors:
    // NOT_FOUND:
    // - no process instance exists with the given key
    virtual ::grpc::Status CancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::gateway_protocol::CancelProcessInstanceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CancelProcessInstanceResponse>> AsyncCancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CancelProcessInstanceResponse>>(AsyncCancelProcessInstanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CancelProcessInstanceResponse>> PrepareAsyncCancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CancelProcessInstanceResponse>>(PrepareAsyncCancelProcessInstanceRaw(context, request, cq));
    }
    //
    // Completes a job with the given variables, which allows completing the associated service task.
    //
    // Errors:
    // NOT_FOUND:
    // - no job exists with the given job key. Note that since jobs are removed once completed,
    // it could be that this job did exist at some point.
    //
    // FAILED_PRECONDITION:
    // - the job was marked as failed. In that case, the related incident must be resolved before
    // the job can be activated again and completed.
    virtual ::grpc::Status CompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::gateway_protocol::CompleteJobResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CompleteJobResponse>> AsyncCompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CompleteJobResponse>>(AsyncCompleteJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CompleteJobResponse>> PrepareAsyncCompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CompleteJobResponse>>(PrepareAsyncCompleteJobRaw(context, request, cq));
    }
    //
    // Creates and starts an instance of the specified process. The process definition to use to
    // create the instance can be specified either using its unique key (as returned by
    // DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
    // latest deployed version. Note that only processes with none start events can be started through
    // this command.
    //
    // Errors:
    // NOT_FOUND:
    // - no process with the given key exists (if processDefinitionKey was given)
    // - no process with the given process ID exists (if bpmnProcessId was given but version was -1)
    // - no process with the given process ID and version exists (if both bpmnProcessId and version were given)
    //
    // FAILED_PRECONDITION:
    // - the process definition does not contain a none start event; only processes with none
    // start event can be started manually.
    //
    // INVALID_ARGUMENT:
    // - the given variables argument is not a valid JSON document; it is expected to be a valid
    // JSON document where the root node is an object.
    virtual ::grpc::Status CreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::gateway_protocol::CreateProcessInstanceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceResponse>> AsyncCreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceResponse>>(AsyncCreateProcessInstanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceResponse>> PrepareAsyncCreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceResponse>>(PrepareAsyncCreateProcessInstanceRaw(context, request, cq));
    }
    //
    // Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
    virtual ::grpc::Status CreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceWithResultResponse>> AsyncCreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceWithResultResponse>>(AsyncCreateProcessInstanceWithResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceWithResultResponse>> PrepareAsyncCreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceWithResultResponse>>(PrepareAsyncCreateProcessInstanceWithResultRaw(context, request, cq));
    }
    //
    // Deploys one or more processes to Zeebe. Note that this is an atomic call,
    // i.e. either all processes are deployed, or none of them are.
    //
    // Errors:
    // INVALID_ARGUMENT:
    // - no resources given.
    // - if at least one resource is invalid. A resource is considered invalid if:
    // - the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
    // - the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
    virtual ::grpc::Status DeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::gateway_protocol::DeployProcessResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployProcessResponse>> AsyncDeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployProcessResponse>>(AsyncDeployProcessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployProcessResponse>> PrepareAsyncDeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployProcessResponse>>(PrepareAsyncDeployProcessRaw(context, request, cq));
    }
    //
    // Deploys one or more resources (e.g. processes or decision models) to Zeebe.
    // Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
    //
    // Errors:
    // INVALID_ARGUMENT:
    // - no resources given.
    // - if at least one resource is invalid. A resource is considered invalid if:
    // - the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
    // - the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
    virtual ::grpc::Status DeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::gateway_protocol::DeployResourceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployResourceResponse>> AsyncDeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployResourceResponse>>(AsyncDeployResourceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployResourceResponse>> PrepareAsyncDeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployResourceResponse>>(PrepareAsyncDeployResourceRaw(context, request, cq));
    }
    //
    // Marks the job as failed; if the retries argument is positive, then the job will be immediately
    // activatable again, and a worker could try again to process it. If it is zero or negative however,
    // an incident will be raised, tagged with the given errorMessage, and the job will not be
    // activatable until the incident is resolved.
    //
    // Errors:
    // NOT_FOUND:
    // - no job was found with the given key
    //
    // FAILED_PRECONDITION:
    // - the job was not activated
    // - the job is already in a failed state, i.e. ran out of retries
    virtual ::grpc::Status FailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::gateway_protocol::FailJobResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::FailJobResponse>> AsyncFailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::FailJobResponse>>(AsyncFailJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::FailJobResponse>> PrepareAsyncFailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::FailJobResponse>>(PrepareAsyncFailJobRaw(context, request, cq));
    }
    //
    // Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
    //
    // Errors:
    // NOT_FOUND:
    // - no job was found with the given key
    //
    // FAILED_PRECONDITION:
    // - the job is not in an activated state
    virtual ::grpc::Status ThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::gateway_protocol::ThrowErrorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ThrowErrorResponse>> AsyncThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ThrowErrorResponse>>(AsyncThrowErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ThrowErrorResponse>> PrepareAsyncThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ThrowErrorResponse>>(PrepareAsyncThrowErrorRaw(context, request, cq));
    }
    //
    // Publishes a single message. Messages are published to specific partitions computed from their
    // correlation keys.
    //
    // Errors:
    // ALREADY_EXISTS:
    // - a message with the same ID was previously published (and is still alive)
    virtual ::grpc::Status PublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::gateway_protocol::PublishMessageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::PublishMessageResponse>> AsyncPublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::PublishMessageResponse>>(AsyncPublishMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::PublishMessageResponse>> PrepareAsyncPublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::PublishMessageResponse>>(PrepareAsyncPublishMessageRaw(context, request, cq));
    }
    //
    // Resolves a given incident. This simply marks the incident as resolved; most likely a call to
    // UpdateJobRetries or SetVariables will be necessary to actually resolve the
    // problem, following by this call.
    //
    // Errors:
    // NOT_FOUND:
    // - no incident with the given key exists
    virtual ::grpc::Status ResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::gateway_protocol::ResolveIncidentResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ResolveIncidentResponse>> AsyncResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ResolveIncidentResponse>>(AsyncResolveIncidentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ResolveIncidentResponse>> PrepareAsyncResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ResolveIncidentResponse>>(PrepareAsyncResolveIncidentRaw(context, request, cq));
    }
    //
    // Updates all the variables of a particular scope (e.g. process instance, flow element instance)
    // from the given JSON document.
    //
    // Errors:
    // NOT_FOUND:
    // - no element with the given elementInstanceKey exists
    // INVALID_ARGUMENT:
    // - the given variables document is not a valid JSON document; valid documents are expected to
    // be JSON documents where the root node is an object.
    virtual ::grpc::Status SetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::gateway_protocol::SetVariablesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::SetVariablesResponse>> AsyncSetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::SetVariablesResponse>>(AsyncSetVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::SetVariablesResponse>> PrepareAsyncSetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::SetVariablesResponse>>(PrepareAsyncSetVariablesRaw(context, request, cq));
    }
    //
    // Obtains the current topology of the cluster the gateway is part of.
    virtual ::grpc::Status Topology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::gateway_protocol::TopologyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::TopologyResponse>> AsyncTopology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::TopologyResponse>>(AsyncTopologyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::TopologyResponse>> PrepareAsyncTopology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::TopologyResponse>>(PrepareAsyncTopologyRaw(context, request, cq));
    }
    //
    // Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
    // retries, should the underlying problem be solved.
    //
    // Errors:
    // NOT_FOUND:
    // - no job exists with the given key
    //
    // INVALID_ARGUMENT:
    // - retries is not greater than 0
    virtual ::grpc::Status UpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::gateway_protocol::UpdateJobRetriesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::UpdateJobRetriesResponse>> AsyncUpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::UpdateJobRetriesResponse>>(AsyncUpdateJobRetriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::UpdateJobRetriesResponse>> PrepareAsyncUpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::UpdateJobRetriesResponse>>(PrepareAsyncUpdateJobRetriesRaw(context, request, cq));
    }
    //
    // Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
    //
    // Errors:
    // NOT_FOUND:
    // - no process instance exists with the given key
    //
    // FAILED_PRECONDITION:
    // - trying to activate element inside of a multi-instance
    //
    // INVALID_ARGUMENT:
    // - activating or terminating unknown element
    // - ancestor of element for activation doesn't exist
    // - scope of variable is unknown
    virtual ::grpc::Status ModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::gateway_protocol::ModifyProcessInstanceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ModifyProcessInstanceResponse>> AsyncModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ModifyProcessInstanceResponse>>(AsyncModifyProcessInstanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ModifyProcessInstanceResponse>> PrepareAsyncModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ModifyProcessInstanceResponse>>(PrepareAsyncModifyProcessInstanceRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      //
      // Iterates through all known partitions round-robin and activates up to the requested
      // maximum and streams them back to the client as they are activated.
      //
      // Errors:
      // INVALID_ARGUMENT:
      // - type is blank (empty string, null)
      // - worker is blank (empty string, null)
      // - timeout less than 1
      // - maxJobsToActivate is less than 1
      virtual void ActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest* request, ::grpc::ClientReadReactor< ::gateway_protocol::ActivateJobsResponse>* reactor) = 0;
      //
      // Cancels a running process instance
      //
      // Errors:
      // NOT_FOUND:
      // - no process instance exists with the given key
      virtual void CancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest* request, ::gateway_protocol::CancelProcessInstanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest* request, ::gateway_protocol::CancelProcessInstanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Completes a job with the given variables, which allows completing the associated service task.
      //
      // Errors:
      // NOT_FOUND:
      // - no job exists with the given job key. Note that since jobs are removed once completed,
      // it could be that this job did exist at some point.
      //
      // FAILED_PRECONDITION:
      // - the job was marked as failed. In that case, the related incident must be resolved before
      // the job can be activated again and completed.
      virtual void CompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest* request, ::gateway_protocol::CompleteJobResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest* request, ::gateway_protocol::CompleteJobResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Creates and starts an instance of the specified process. The process definition to use to
      // create the instance can be specified either using its unique key (as returned by
      // DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
      // latest deployed version. Note that only processes with none start events can be started through
      // this command.
      //
      // Errors:
      // NOT_FOUND:
      // - no process with the given key exists (if processDefinitionKey was given)
      // - no process with the given process ID exists (if bpmnProcessId was given but version was -1)
      // - no process with the given process ID and version exists (if both bpmnProcessId and version were given)
      //
      // FAILED_PRECONDITION:
      // - the process definition does not contain a none start event; only processes with none
      // start event can be started manually.
      //
      // INVALID_ARGUMENT:
      // - the given variables argument is not a valid JSON document; it is expected to be a valid
      // JSON document where the root node is an object.
      virtual void CreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest* request, ::gateway_protocol::CreateProcessInstanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest* request, ::gateway_protocol::CreateProcessInstanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
      virtual void CreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Deploys one or more processes to Zeebe. Note that this is an atomic call,
      // i.e. either all processes are deployed, or none of them are.
      //
      // Errors:
      // INVALID_ARGUMENT:
      // - no resources given.
      // - if at least one resource is invalid. A resource is considered invalid if:
      // - the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
      // - the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      virtual void DeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest* request, ::gateway_protocol::DeployProcessResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest* request, ::gateway_protocol::DeployProcessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Deploys one or more resources (e.g. processes or decision models) to Zeebe.
      // Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
      //
      // Errors:
      // INVALID_ARGUMENT:
      // - no resources given.
      // - if at least one resource is invalid. A resource is considered invalid if:
      // - the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
      // - the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      virtual void DeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest* request, ::gateway_protocol::DeployResourceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest* request, ::gateway_protocol::DeployResourceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Marks the job as failed; if the retries argument is positive, then the job will be immediately
      // activatable again, and a worker could try again to process it. If it is zero or negative however,
      // an incident will be raised, tagged with the given errorMessage, and the job will not be
      // activatable until the incident is resolved.
      //
      // Errors:
      // NOT_FOUND:
      // - no job was found with the given key
      //
      // FAILED_PRECONDITION:
      // - the job was not activated
      // - the job is already in a failed state, i.e. ran out of retries
      virtual void FailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest* request, ::gateway_protocol::FailJobResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest* request, ::gateway_protocol::FailJobResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
      //
      // Errors:
      // NOT_FOUND:
      // - no job was found with the given key
      //
      // FAILED_PRECONDITION:
      // - the job is not in an activated state
      virtual void ThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest* request, ::gateway_protocol::ThrowErrorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest* request, ::gateway_protocol::ThrowErrorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Publishes a single message. Messages are published to specific partitions computed from their
      // correlation keys.
      //
      // Errors:
      // ALREADY_EXISTS:
      // - a message with the same ID was previously published (and is still alive)
      virtual void PublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest* request, ::gateway_protocol::PublishMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest* request, ::gateway_protocol::PublishMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Resolves a given incident. This simply marks the incident as resolved; most likely a call to
      // UpdateJobRetries or SetVariables will be necessary to actually resolve the
      // problem, following by this call.
      //
      // Errors:
      // NOT_FOUND:
      // - no incident with the given key exists
      virtual void ResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest* request, ::gateway_protocol::ResolveIncidentResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest* request, ::gateway_protocol::ResolveIncidentResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Updates all the variables of a particular scope (e.g. process instance, flow element instance)
      // from the given JSON document.
      //
      // Errors:
      // NOT_FOUND:
      // - no element with the given elementInstanceKey exists
      // INVALID_ARGUMENT:
      // - the given variables document is not a valid JSON document; valid documents are expected to
      // be JSON documents where the root node is an object.
      virtual void SetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest* request, ::gateway_protocol::SetVariablesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest* request, ::gateway_protocol::SetVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Obtains the current topology of the cluster the gateway is part of.
      virtual void Topology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest* request, ::gateway_protocol::TopologyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Topology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest* request, ::gateway_protocol::TopologyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
      // retries, should the underlying problem be solved.
      //
      // Errors:
      // NOT_FOUND:
      // - no job exists with the given key
      //
      // INVALID_ARGUMENT:
      // - retries is not greater than 0
      virtual void UpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest* request, ::gateway_protocol::UpdateJobRetriesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest* request, ::gateway_protocol::UpdateJobRetriesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
      //
      // Errors:
      // NOT_FOUND:
      // - no process instance exists with the given key
      //
      // FAILED_PRECONDITION:
      // - trying to activate element inside of a multi-instance
      //
      // INVALID_ARGUMENT:
      // - activating or terminating unknown element
      // - ancestor of element for activation doesn't exist
      // - scope of variable is unknown
      virtual void ModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest* request, ::gateway_protocol::ModifyProcessInstanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest* request, ::gateway_protocol::ModifyProcessInstanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::gateway_protocol::ActivateJobsResponse>* ActivateJobsRaw(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::gateway_protocol::ActivateJobsResponse>* AsyncActivateJobsRaw(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::gateway_protocol::ActivateJobsResponse>* PrepareAsyncActivateJobsRaw(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CancelProcessInstanceResponse>* AsyncCancelProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CancelProcessInstanceResponse>* PrepareAsyncCancelProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CompleteJobResponse>* AsyncCompleteJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CompleteJobResponse>* PrepareAsyncCompleteJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceResponse>* AsyncCreateProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceResponse>* PrepareAsyncCreateProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceWithResultResponse>* AsyncCreateProcessInstanceWithResultRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::CreateProcessInstanceWithResultResponse>* PrepareAsyncCreateProcessInstanceWithResultRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployProcessResponse>* AsyncDeployProcessRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployProcessResponse>* PrepareAsyncDeployProcessRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployResourceResponse>* AsyncDeployResourceRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::DeployResourceResponse>* PrepareAsyncDeployResourceRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::FailJobResponse>* AsyncFailJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::FailJobResponse>* PrepareAsyncFailJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ThrowErrorResponse>* AsyncThrowErrorRaw(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ThrowErrorResponse>* PrepareAsyncThrowErrorRaw(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::PublishMessageResponse>* AsyncPublishMessageRaw(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::PublishMessageResponse>* PrepareAsyncPublishMessageRaw(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ResolveIncidentResponse>* AsyncResolveIncidentRaw(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ResolveIncidentResponse>* PrepareAsyncResolveIncidentRaw(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::SetVariablesResponse>* AsyncSetVariablesRaw(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::SetVariablesResponse>* PrepareAsyncSetVariablesRaw(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::TopologyResponse>* AsyncTopologyRaw(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::TopologyResponse>* PrepareAsyncTopologyRaw(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::UpdateJobRetriesResponse>* AsyncUpdateJobRetriesRaw(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::UpdateJobRetriesResponse>* PrepareAsyncUpdateJobRetriesRaw(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ModifyProcessInstanceResponse>* AsyncModifyProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::gateway_protocol::ModifyProcessInstanceResponse>* PrepareAsyncModifyProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::gateway_protocol::ActivateJobsResponse>> ActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::gateway_protocol::ActivateJobsResponse>>(ActivateJobsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::gateway_protocol::ActivateJobsResponse>> AsyncActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::gateway_protocol::ActivateJobsResponse>>(AsyncActivateJobsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::gateway_protocol::ActivateJobsResponse>> PrepareAsyncActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::gateway_protocol::ActivateJobsResponse>>(PrepareAsyncActivateJobsRaw(context, request, cq));
    }
    ::grpc::Status CancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::gateway_protocol::CancelProcessInstanceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CancelProcessInstanceResponse>> AsyncCancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CancelProcessInstanceResponse>>(AsyncCancelProcessInstanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CancelProcessInstanceResponse>> PrepareAsyncCancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CancelProcessInstanceResponse>>(PrepareAsyncCancelProcessInstanceRaw(context, request, cq));
    }
    ::grpc::Status CompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::gateway_protocol::CompleteJobResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CompleteJobResponse>> AsyncCompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CompleteJobResponse>>(AsyncCompleteJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CompleteJobResponse>> PrepareAsyncCompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CompleteJobResponse>>(PrepareAsyncCompleteJobRaw(context, request, cq));
    }
    ::grpc::Status CreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::gateway_protocol::CreateProcessInstanceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceResponse>> AsyncCreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceResponse>>(AsyncCreateProcessInstanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceResponse>> PrepareAsyncCreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceResponse>>(PrepareAsyncCreateProcessInstanceRaw(context, request, cq));
    }
    ::grpc::Status CreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceWithResultResponse>> AsyncCreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceWithResultResponse>>(AsyncCreateProcessInstanceWithResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceWithResultResponse>> PrepareAsyncCreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceWithResultResponse>>(PrepareAsyncCreateProcessInstanceWithResultRaw(context, request, cq));
    }
    ::grpc::Status DeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::gateway_protocol::DeployProcessResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployProcessResponse>> AsyncDeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployProcessResponse>>(AsyncDeployProcessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployProcessResponse>> PrepareAsyncDeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployProcessResponse>>(PrepareAsyncDeployProcessRaw(context, request, cq));
    }
    ::grpc::Status DeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::gateway_protocol::DeployResourceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployResourceResponse>> AsyncDeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployResourceResponse>>(AsyncDeployResourceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployResourceResponse>> PrepareAsyncDeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployResourceResponse>>(PrepareAsyncDeployResourceRaw(context, request, cq));
    }
    ::grpc::Status FailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::gateway_protocol::FailJobResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::FailJobResponse>> AsyncFailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::FailJobResponse>>(AsyncFailJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::FailJobResponse>> PrepareAsyncFailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::FailJobResponse>>(PrepareAsyncFailJobRaw(context, request, cq));
    }
    ::grpc::Status ThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::gateway_protocol::ThrowErrorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ThrowErrorResponse>> AsyncThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ThrowErrorResponse>>(AsyncThrowErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ThrowErrorResponse>> PrepareAsyncThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ThrowErrorResponse>>(PrepareAsyncThrowErrorRaw(context, request, cq));
    }
    ::grpc::Status PublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::gateway_protocol::PublishMessageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::PublishMessageResponse>> AsyncPublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::PublishMessageResponse>>(AsyncPublishMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::PublishMessageResponse>> PrepareAsyncPublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::PublishMessageResponse>>(PrepareAsyncPublishMessageRaw(context, request, cq));
    }
    ::grpc::Status ResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::gateway_protocol::ResolveIncidentResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ResolveIncidentResponse>> AsyncResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ResolveIncidentResponse>>(AsyncResolveIncidentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ResolveIncidentResponse>> PrepareAsyncResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ResolveIncidentResponse>>(PrepareAsyncResolveIncidentRaw(context, request, cq));
    }
    ::grpc::Status SetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::gateway_protocol::SetVariablesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::SetVariablesResponse>> AsyncSetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::SetVariablesResponse>>(AsyncSetVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::SetVariablesResponse>> PrepareAsyncSetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::SetVariablesResponse>>(PrepareAsyncSetVariablesRaw(context, request, cq));
    }
    ::grpc::Status Topology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::gateway_protocol::TopologyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::TopologyResponse>> AsyncTopology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::TopologyResponse>>(AsyncTopologyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::TopologyResponse>> PrepareAsyncTopology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::TopologyResponse>>(PrepareAsyncTopologyRaw(context, request, cq));
    }
    ::grpc::Status UpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::gateway_protocol::UpdateJobRetriesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::UpdateJobRetriesResponse>> AsyncUpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::UpdateJobRetriesResponse>>(AsyncUpdateJobRetriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::UpdateJobRetriesResponse>> PrepareAsyncUpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::UpdateJobRetriesResponse>>(PrepareAsyncUpdateJobRetriesRaw(context, request, cq));
    }
    ::grpc::Status ModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::gateway_protocol::ModifyProcessInstanceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ModifyProcessInstanceResponse>> AsyncModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ModifyProcessInstanceResponse>>(AsyncModifyProcessInstanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ModifyProcessInstanceResponse>> PrepareAsyncModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ModifyProcessInstanceResponse>>(PrepareAsyncModifyProcessInstanceRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ActivateJobs(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest* request, ::grpc::ClientReadReactor< ::gateway_protocol::ActivateJobsResponse>* reactor) override;
      void CancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest* request, ::gateway_protocol::CancelProcessInstanceResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest* request, ::gateway_protocol::CancelProcessInstanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest* request, ::gateway_protocol::CompleteJobResponse* response, std::function<void(::grpc::Status)>) override;
      void CompleteJob(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest* request, ::gateway_protocol::CompleteJobResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest* request, ::gateway_protocol::CreateProcessInstanceResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest* request, ::gateway_protocol::CreateProcessInstanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateProcessInstanceWithResult(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest* request, ::gateway_protocol::DeployProcessResponse* response, std::function<void(::grpc::Status)>) override;
      void DeployProcess(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest* request, ::gateway_protocol::DeployProcessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest* request, ::gateway_protocol::DeployResourceResponse* response, std::function<void(::grpc::Status)>) override;
      void DeployResource(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest* request, ::gateway_protocol::DeployResourceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest* request, ::gateway_protocol::FailJobResponse* response, std::function<void(::grpc::Status)>) override;
      void FailJob(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest* request, ::gateway_protocol::FailJobResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest* request, ::gateway_protocol::ThrowErrorResponse* response, std::function<void(::grpc::Status)>) override;
      void ThrowError(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest* request, ::gateway_protocol::ThrowErrorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest* request, ::gateway_protocol::PublishMessageResponse* response, std::function<void(::grpc::Status)>) override;
      void PublishMessage(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest* request, ::gateway_protocol::PublishMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest* request, ::gateway_protocol::ResolveIncidentResponse* response, std::function<void(::grpc::Status)>) override;
      void ResolveIncident(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest* request, ::gateway_protocol::ResolveIncidentResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest* request, ::gateway_protocol::SetVariablesResponse* response, std::function<void(::grpc::Status)>) override;
      void SetVariables(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest* request, ::gateway_protocol::SetVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Topology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest* request, ::gateway_protocol::TopologyResponse* response, std::function<void(::grpc::Status)>) override;
      void Topology(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest* request, ::gateway_protocol::TopologyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest* request, ::gateway_protocol::UpdateJobRetriesResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateJobRetries(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest* request, ::gateway_protocol::UpdateJobRetriesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest* request, ::gateway_protocol::ModifyProcessInstanceResponse* response, std::function<void(::grpc::Status)>) override;
      void ModifyProcessInstance(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest* request, ::gateway_protocol::ModifyProcessInstanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::gateway_protocol::ActivateJobsResponse>* ActivateJobsRaw(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request) override;
    ::grpc::ClientAsyncReader< ::gateway_protocol::ActivateJobsResponse>* AsyncActivateJobsRaw(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::gateway_protocol::ActivateJobsResponse>* PrepareAsyncActivateJobsRaw(::grpc::ClientContext* context, const ::gateway_protocol::ActivateJobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CancelProcessInstanceResponse>* AsyncCancelProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CancelProcessInstanceResponse>* PrepareAsyncCancelProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CancelProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CompleteJobResponse>* AsyncCompleteJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CompleteJobResponse>* PrepareAsyncCompleteJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::CompleteJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceResponse>* AsyncCreateProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceResponse>* PrepareAsyncCreateProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceWithResultResponse>* AsyncCreateProcessInstanceWithResultRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::CreateProcessInstanceWithResultResponse>* PrepareAsyncCreateProcessInstanceWithResultRaw(::grpc::ClientContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployProcessResponse>* AsyncDeployProcessRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployProcessResponse>* PrepareAsyncDeployProcessRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployProcessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployResourceResponse>* AsyncDeployResourceRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::DeployResourceResponse>* PrepareAsyncDeployResourceRaw(::grpc::ClientContext* context, const ::gateway_protocol::DeployResourceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::FailJobResponse>* AsyncFailJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::FailJobResponse>* PrepareAsyncFailJobRaw(::grpc::ClientContext* context, const ::gateway_protocol::FailJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ThrowErrorResponse>* AsyncThrowErrorRaw(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ThrowErrorResponse>* PrepareAsyncThrowErrorRaw(::grpc::ClientContext* context, const ::gateway_protocol::ThrowErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::PublishMessageResponse>* AsyncPublishMessageRaw(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::PublishMessageResponse>* PrepareAsyncPublishMessageRaw(::grpc::ClientContext* context, const ::gateway_protocol::PublishMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ResolveIncidentResponse>* AsyncResolveIncidentRaw(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ResolveIncidentResponse>* PrepareAsyncResolveIncidentRaw(::grpc::ClientContext* context, const ::gateway_protocol::ResolveIncidentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::SetVariablesResponse>* AsyncSetVariablesRaw(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::SetVariablesResponse>* PrepareAsyncSetVariablesRaw(::grpc::ClientContext* context, const ::gateway_protocol::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::TopologyResponse>* AsyncTopologyRaw(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::TopologyResponse>* PrepareAsyncTopologyRaw(::grpc::ClientContext* context, const ::gateway_protocol::TopologyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::UpdateJobRetriesResponse>* AsyncUpdateJobRetriesRaw(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::UpdateJobRetriesResponse>* PrepareAsyncUpdateJobRetriesRaw(::grpc::ClientContext* context, const ::gateway_protocol::UpdateJobRetriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ModifyProcessInstanceResponse>* AsyncModifyProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::gateway_protocol::ModifyProcessInstanceResponse>* PrepareAsyncModifyProcessInstanceRaw(::grpc::ClientContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ActivateJobs_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelProcessInstance_;
    const ::grpc::internal::RpcMethod rpcmethod_CompleteJob_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateProcessInstance_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateProcessInstanceWithResult_;
    const ::grpc::internal::RpcMethod rpcmethod_DeployProcess_;
    const ::grpc::internal::RpcMethod rpcmethod_DeployResource_;
    const ::grpc::internal::RpcMethod rpcmethod_FailJob_;
    const ::grpc::internal::RpcMethod rpcmethod_ThrowError_;
    const ::grpc::internal::RpcMethod rpcmethod_PublishMessage_;
    const ::grpc::internal::RpcMethod rpcmethod_ResolveIncident_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVariables_;
    const ::grpc::internal::RpcMethod rpcmethod_Topology_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateJobRetries_;
    const ::grpc::internal::RpcMethod rpcmethod_ModifyProcessInstance_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //
    // Iterates through all known partitions round-robin and activates up to the requested
    // maximum and streams them back to the client as they are activated.
    //
    // Errors:
    // INVALID_ARGUMENT:
    // - type is blank (empty string, null)
    // - worker is blank (empty string, null)
    // - timeout less than 1
    // - maxJobsToActivate is less than 1
    virtual ::grpc::Status ActivateJobs(::grpc::ServerContext* context, const ::gateway_protocol::ActivateJobsRequest* request, ::grpc::ServerWriter< ::gateway_protocol::ActivateJobsResponse>* writer);
    //
    // Cancels a running process instance
    //
    // Errors:
    // NOT_FOUND:
    // - no process instance exists with the given key
    virtual ::grpc::Status CancelProcessInstance(::grpc::ServerContext* context, const ::gateway_protocol::CancelProcessInstanceRequest* request, ::gateway_protocol::CancelProcessInstanceResponse* response);
    //
    // Completes a job with the given variables, which allows completing the associated service task.
    //
    // Errors:
    // NOT_FOUND:
    // - no job exists with the given job key. Note that since jobs are removed once completed,
    // it could be that this job did exist at some point.
    //
    // FAILED_PRECONDITION:
    // - the job was marked as failed. In that case, the related incident must be resolved before
    // the job can be activated again and completed.
    virtual ::grpc::Status CompleteJob(::grpc::ServerContext* context, const ::gateway_protocol::CompleteJobRequest* request, ::gateway_protocol::CompleteJobResponse* response);
    //
    // Creates and starts an instance of the specified process. The process definition to use to
    // create the instance can be specified either using its unique key (as returned by
    // DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
    // latest deployed version. Note that only processes with none start events can be started through
    // this command.
    //
    // Errors:
    // NOT_FOUND:
    // - no process with the given key exists (if processDefinitionKey was given)
    // - no process with the given process ID exists (if bpmnProcessId was given but version was -1)
    // - no process with the given process ID and version exists (if both bpmnProcessId and version were given)
    //
    // FAILED_PRECONDITION:
    // - the process definition does not contain a none start event; only processes with none
    // start event can be started manually.
    //
    // INVALID_ARGUMENT:
    // - the given variables argument is not a valid JSON document; it is expected to be a valid
    // JSON document where the root node is an object.
    virtual ::grpc::Status CreateProcessInstance(::grpc::ServerContext* context, const ::gateway_protocol::CreateProcessInstanceRequest* request, ::gateway_protocol::CreateProcessInstanceResponse* response);
    //
    // Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
    virtual ::grpc::Status CreateProcessInstanceWithResult(::grpc::ServerContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response);
    //
    // Deploys one or more processes to Zeebe. Note that this is an atomic call,
    // i.e. either all processes are deployed, or none of them are.
    //
    // Errors:
    // INVALID_ARGUMENT:
    // - no resources given.
    // - if at least one resource is invalid. A resource is considered invalid if:
    // - the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
    // - the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
    virtual ::grpc::Status DeployProcess(::grpc::ServerContext* context, const ::gateway_protocol::DeployProcessRequest* request, ::gateway_protocol::DeployProcessResponse* response);
    //
    // Deploys one or more resources (e.g. processes or decision models) to Zeebe.
    // Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
    //
    // Errors:
    // INVALID_ARGUMENT:
    // - no resources given.
    // - if at least one resource is invalid. A resource is considered invalid if:
    // - the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
    // - the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
    virtual ::grpc::Status DeployResource(::grpc::ServerContext* context, const ::gateway_protocol::DeployResourceRequest* request, ::gateway_protocol::DeployResourceResponse* response);
    //
    // Marks the job as failed; if the retries argument is positive, then the job will be immediately
    // activatable again, and a worker could try again to process it. If it is zero or negative however,
    // an incident will be raised, tagged with the given errorMessage, and the job will not be
    // activatable until the incident is resolved.
    //
    // Errors:
    // NOT_FOUND:
    // - no job was found with the given key
    //
    // FAILED_PRECONDITION:
    // - the job was not activated
    // - the job is already in a failed state, i.e. ran out of retries
    virtual ::grpc::Status FailJob(::grpc::ServerContext* context, const ::gateway_protocol::FailJobRequest* request, ::gateway_protocol::FailJobResponse* response);
    //
    // Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
    //
    // Errors:
    // NOT_FOUND:
    // - no job was found with the given key
    //
    // FAILED_PRECONDITION:
    // - the job is not in an activated state
    virtual ::grpc::Status ThrowError(::grpc::ServerContext* context, const ::gateway_protocol::ThrowErrorRequest* request, ::gateway_protocol::ThrowErrorResponse* response);
    //
    // Publishes a single message. Messages are published to specific partitions computed from their
    // correlation keys.
    //
    // Errors:
    // ALREADY_EXISTS:
    // - a message with the same ID was previously published (and is still alive)
    virtual ::grpc::Status PublishMessage(::grpc::ServerContext* context, const ::gateway_protocol::PublishMessageRequest* request, ::gateway_protocol::PublishMessageResponse* response);
    //
    // Resolves a given incident. This simply marks the incident as resolved; most likely a call to
    // UpdateJobRetries or SetVariables will be necessary to actually resolve the
    // problem, following by this call.
    //
    // Errors:
    // NOT_FOUND:
    // - no incident with the given key exists
    virtual ::grpc::Status ResolveIncident(::grpc::ServerContext* context, const ::gateway_protocol::ResolveIncidentRequest* request, ::gateway_protocol::ResolveIncidentResponse* response);
    //
    // Updates all the variables of a particular scope (e.g. process instance, flow element instance)
    // from the given JSON document.
    //
    // Errors:
    // NOT_FOUND:
    // - no element with the given elementInstanceKey exists
    // INVALID_ARGUMENT:
    // - the given variables document is not a valid JSON document; valid documents are expected to
    // be JSON documents where the root node is an object.
    virtual ::grpc::Status SetVariables(::grpc::ServerContext* context, const ::gateway_protocol::SetVariablesRequest* request, ::gateway_protocol::SetVariablesResponse* response);
    //
    // Obtains the current topology of the cluster the gateway is part of.
    virtual ::grpc::Status Topology(::grpc::ServerContext* context, const ::gateway_protocol::TopologyRequest* request, ::gateway_protocol::TopologyResponse* response);
    //
    // Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
    // retries, should the underlying problem be solved.
    //
    // Errors:
    // NOT_FOUND:
    // - no job exists with the given key
    //
    // INVALID_ARGUMENT:
    // - retries is not greater than 0
    virtual ::grpc::Status UpdateJobRetries(::grpc::ServerContext* context, const ::gateway_protocol::UpdateJobRetriesRequest* request, ::gateway_protocol::UpdateJobRetriesResponse* response);
    //
    // Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
    //
    // Errors:
    // NOT_FOUND:
    // - no process instance exists with the given key
    //
    // FAILED_PRECONDITION:
    // - trying to activate element inside of a multi-instance
    //
    // INVALID_ARGUMENT:
    // - activating or terminating unknown element
    // - ancestor of element for activation doesn't exist
    // - scope of variable is unknown
    virtual ::grpc::Status ModifyProcessInstance(::grpc::ServerContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest* request, ::gateway_protocol::ModifyProcessInstanceResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ActivateJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ActivateJobs() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ActivateJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateJobs(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ActivateJobsRequest* /*request*/, ::grpc::ServerWriter< ::gateway_protocol::ActivateJobsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActivateJobs(::grpc::ServerContext* context, ::gateway_protocol::ActivateJobsRequest* request, ::grpc::ServerAsyncWriter< ::gateway_protocol::ActivateJobsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelProcessInstance() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CancelProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CancelProcessInstanceRequest* /*request*/, ::gateway_protocol::CancelProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelProcessInstance(::grpc::ServerContext* context, ::gateway_protocol::CancelProcessInstanceRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::CancelProcessInstanceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CompleteJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CompleteJob() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CompleteJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CompleteJobRequest* /*request*/, ::gateway_protocol::CompleteJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompleteJob(::grpc::ServerContext* context, ::gateway_protocol::CompleteJobRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::CompleteJobResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateProcessInstance() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_CreateProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateProcessInstance(::grpc::ServerContext* context, ::gateway_protocol::CreateProcessInstanceRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::CreateProcessInstanceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateProcessInstanceWithResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateProcessInstanceWithResult() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CreateProcessInstanceWithResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstanceWithResult(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceWithResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateProcessInstanceWithResult(::grpc::ServerContext* context, ::gateway_protocol::CreateProcessInstanceWithResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::CreateProcessInstanceWithResultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeployProcess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeployProcess() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_DeployProcess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployProcess(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployProcessRequest* /*request*/, ::gateway_protocol::DeployProcessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeployProcess(::grpc::ServerContext* context, ::gateway_protocol::DeployProcessRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::DeployProcessResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeployResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeployResource() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeployResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployResource(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployResourceRequest* /*request*/, ::gateway_protocol::DeployResourceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeployResource(::grpc::ServerContext* context, ::gateway_protocol::DeployResourceRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::DeployResourceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FailJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FailJob() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_FailJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FailJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::FailJobRequest* /*request*/, ::gateway_protocol::FailJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFailJob(::grpc::ServerContext* context, ::gateway_protocol::FailJobRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::FailJobResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ThrowError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ThrowError() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ThrowError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ThrowError(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ThrowErrorRequest* /*request*/, ::gateway_protocol::ThrowErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestThrowError(::grpc::ServerContext* context, ::gateway_protocol::ThrowErrorRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::ThrowErrorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PublishMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PublishMessage() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_PublishMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishMessage(::grpc::ServerContext* /*context*/, const ::gateway_protocol::PublishMessageRequest* /*request*/, ::gateway_protocol::PublishMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishMessage(::grpc::ServerContext* context, ::gateway_protocol::PublishMessageRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::PublishMessageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResolveIncident : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResolveIncident() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ResolveIncident() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveIncident(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ResolveIncidentRequest* /*request*/, ::gateway_protocol::ResolveIncidentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResolveIncident(::grpc::ServerContext* context, ::gateway_protocol::ResolveIncidentRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::ResolveIncidentResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVariables() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::gateway_protocol::SetVariablesRequest* /*request*/, ::gateway_protocol::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariables(::grpc::ServerContext* context, ::gateway_protocol::SetVariablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::SetVariablesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Topology() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_Topology() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Topology(::grpc::ServerContext* /*context*/, const ::gateway_protocol::TopologyRequest* /*request*/, ::gateway_protocol::TopologyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTopology(::grpc::ServerContext* context, ::gateway_protocol::TopologyRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::TopologyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateJobRetries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateJobRetries() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_UpdateJobRetries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateJobRetries(::grpc::ServerContext* /*context*/, const ::gateway_protocol::UpdateJobRetriesRequest* /*request*/, ::gateway_protocol::UpdateJobRetriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateJobRetries(::grpc::ServerContext* context, ::gateway_protocol::UpdateJobRetriesRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::UpdateJobRetriesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ModifyProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ModifyProcessInstance() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ModifyProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ModifyProcessInstanceRequest* /*request*/, ::gateway_protocol::ModifyProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModifyProcessInstance(::grpc::ServerContext* context, ::gateway_protocol::ModifyProcessInstanceRequest* request, ::grpc::ServerAsyncResponseWriter< ::gateway_protocol::ModifyProcessInstanceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ActivateJobs<WithAsyncMethod_CancelProcessInstance<WithAsyncMethod_CompleteJob<WithAsyncMethod_CreateProcessInstance<WithAsyncMethod_CreateProcessInstanceWithResult<WithAsyncMethod_DeployProcess<WithAsyncMethod_DeployResource<WithAsyncMethod_FailJob<WithAsyncMethod_ThrowError<WithAsyncMethod_PublishMessage<WithAsyncMethod_ResolveIncident<WithAsyncMethod_SetVariables<WithAsyncMethod_Topology<WithAsyncMethod_UpdateJobRetries<WithAsyncMethod_ModifyProcessInstance<Service > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ActivateJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ActivateJobs() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::gateway_protocol::ActivateJobsRequest, ::gateway_protocol::ActivateJobsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::ActivateJobsRequest* request) { return this->ActivateJobs(context, request); }));
    }
    ~WithCallbackMethod_ActivateJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateJobs(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ActivateJobsRequest* /*request*/, ::grpc::ServerWriter< ::gateway_protocol::ActivateJobsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::gateway_protocol::ActivateJobsResponse>* ActivateJobs(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::ActivateJobsRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CancelProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CancelProcessInstance() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CancelProcessInstanceRequest, ::gateway_protocol::CancelProcessInstanceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::CancelProcessInstanceRequest* request, ::gateway_protocol::CancelProcessInstanceResponse* response) { return this->CancelProcessInstance(context, request, response); }));}
    void SetMessageAllocatorFor_CancelProcessInstance(
        ::grpc::MessageAllocator< ::gateway_protocol::CancelProcessInstanceRequest, ::gateway_protocol::CancelProcessInstanceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CancelProcessInstanceRequest, ::gateway_protocol::CancelProcessInstanceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CancelProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CancelProcessInstanceRequest* /*request*/, ::gateway_protocol::CancelProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelProcessInstance(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::CancelProcessInstanceRequest* /*request*/, ::gateway_protocol::CancelProcessInstanceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CompleteJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CompleteJob() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CompleteJobRequest, ::gateway_protocol::CompleteJobResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::CompleteJobRequest* request, ::gateway_protocol::CompleteJobResponse* response) { return this->CompleteJob(context, request, response); }));}
    void SetMessageAllocatorFor_CompleteJob(
        ::grpc::MessageAllocator< ::gateway_protocol::CompleteJobRequest, ::gateway_protocol::CompleteJobResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CompleteJobRequest, ::gateway_protocol::CompleteJobResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CompleteJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CompleteJobRequest* /*request*/, ::gateway_protocol::CompleteJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CompleteJob(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::CompleteJobRequest* /*request*/, ::gateway_protocol::CompleteJobResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateProcessInstance() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CreateProcessInstanceRequest, ::gateway_protocol::CreateProcessInstanceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::CreateProcessInstanceRequest* request, ::gateway_protocol::CreateProcessInstanceResponse* response) { return this->CreateProcessInstance(context, request, response); }));}
    void SetMessageAllocatorFor_CreateProcessInstance(
        ::grpc::MessageAllocator< ::gateway_protocol::CreateProcessInstanceRequest, ::gateway_protocol::CreateProcessInstanceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CreateProcessInstanceRequest, ::gateway_protocol::CreateProcessInstanceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateProcessInstance(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateProcessInstanceWithResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateProcessInstanceWithResult() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CreateProcessInstanceWithResultRequest, ::gateway_protocol::CreateProcessInstanceWithResultResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* request, ::gateway_protocol::CreateProcessInstanceWithResultResponse* response) { return this->CreateProcessInstanceWithResult(context, request, response); }));}
    void SetMessageAllocatorFor_CreateProcessInstanceWithResult(
        ::grpc::MessageAllocator< ::gateway_protocol::CreateProcessInstanceWithResultRequest, ::gateway_protocol::CreateProcessInstanceWithResultResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::CreateProcessInstanceWithResultRequest, ::gateway_protocol::CreateProcessInstanceWithResultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateProcessInstanceWithResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstanceWithResult(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceWithResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateProcessInstanceWithResult(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceWithResultResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeployProcess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeployProcess() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::DeployProcessRequest, ::gateway_protocol::DeployProcessResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::DeployProcessRequest* request, ::gateway_protocol::DeployProcessResponse* response) { return this->DeployProcess(context, request, response); }));}
    void SetMessageAllocatorFor_DeployProcess(
        ::grpc::MessageAllocator< ::gateway_protocol::DeployProcessRequest, ::gateway_protocol::DeployProcessResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::DeployProcessRequest, ::gateway_protocol::DeployProcessResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeployProcess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployProcess(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployProcessRequest* /*request*/, ::gateway_protocol::DeployProcessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeployProcess(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::DeployProcessRequest* /*request*/, ::gateway_protocol::DeployProcessResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeployResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeployResource() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::DeployResourceRequest, ::gateway_protocol::DeployResourceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::DeployResourceRequest* request, ::gateway_protocol::DeployResourceResponse* response) { return this->DeployResource(context, request, response); }));}
    void SetMessageAllocatorFor_DeployResource(
        ::grpc::MessageAllocator< ::gateway_protocol::DeployResourceRequest, ::gateway_protocol::DeployResourceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::DeployResourceRequest, ::gateway_protocol::DeployResourceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeployResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployResource(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployResourceRequest* /*request*/, ::gateway_protocol::DeployResourceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeployResource(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::DeployResourceRequest* /*request*/, ::gateway_protocol::DeployResourceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FailJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FailJob() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::FailJobRequest, ::gateway_protocol::FailJobResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::FailJobRequest* request, ::gateway_protocol::FailJobResponse* response) { return this->FailJob(context, request, response); }));}
    void SetMessageAllocatorFor_FailJob(
        ::grpc::MessageAllocator< ::gateway_protocol::FailJobRequest, ::gateway_protocol::FailJobResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::FailJobRequest, ::gateway_protocol::FailJobResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FailJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FailJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::FailJobRequest* /*request*/, ::gateway_protocol::FailJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FailJob(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::FailJobRequest* /*request*/, ::gateway_protocol::FailJobResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ThrowError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ThrowError() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::ThrowErrorRequest, ::gateway_protocol::ThrowErrorResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::ThrowErrorRequest* request, ::gateway_protocol::ThrowErrorResponse* response) { return this->ThrowError(context, request, response); }));}
    void SetMessageAllocatorFor_ThrowError(
        ::grpc::MessageAllocator< ::gateway_protocol::ThrowErrorRequest, ::gateway_protocol::ThrowErrorResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::ThrowErrorRequest, ::gateway_protocol::ThrowErrorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ThrowError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ThrowError(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ThrowErrorRequest* /*request*/, ::gateway_protocol::ThrowErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ThrowError(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::ThrowErrorRequest* /*request*/, ::gateway_protocol::ThrowErrorResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PublishMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PublishMessage() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::PublishMessageRequest, ::gateway_protocol::PublishMessageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::PublishMessageRequest* request, ::gateway_protocol::PublishMessageResponse* response) { return this->PublishMessage(context, request, response); }));}
    void SetMessageAllocatorFor_PublishMessage(
        ::grpc::MessageAllocator< ::gateway_protocol::PublishMessageRequest, ::gateway_protocol::PublishMessageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::PublishMessageRequest, ::gateway_protocol::PublishMessageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PublishMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishMessage(::grpc::ServerContext* /*context*/, const ::gateway_protocol::PublishMessageRequest* /*request*/, ::gateway_protocol::PublishMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PublishMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::PublishMessageRequest* /*request*/, ::gateway_protocol::PublishMessageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResolveIncident : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResolveIncident() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::ResolveIncidentRequest, ::gateway_protocol::ResolveIncidentResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::ResolveIncidentRequest* request, ::gateway_protocol::ResolveIncidentResponse* response) { return this->ResolveIncident(context, request, response); }));}
    void SetMessageAllocatorFor_ResolveIncident(
        ::grpc::MessageAllocator< ::gateway_protocol::ResolveIncidentRequest, ::gateway_protocol::ResolveIncidentResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::ResolveIncidentRequest, ::gateway_protocol::ResolveIncidentResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResolveIncident() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveIncident(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ResolveIncidentRequest* /*request*/, ::gateway_protocol::ResolveIncidentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResolveIncident(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::ResolveIncidentRequest* /*request*/, ::gateway_protocol::ResolveIncidentResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetVariables() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::SetVariablesRequest, ::gateway_protocol::SetVariablesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::SetVariablesRequest* request, ::gateway_protocol::SetVariablesResponse* response) { return this->SetVariables(context, request, response); }));}
    void SetMessageAllocatorFor_SetVariables(
        ::grpc::MessageAllocator< ::gateway_protocol::SetVariablesRequest, ::gateway_protocol::SetVariablesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::SetVariablesRequest, ::gateway_protocol::SetVariablesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::gateway_protocol::SetVariablesRequest* /*request*/, ::gateway_protocol::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::SetVariablesRequest* /*request*/, ::gateway_protocol::SetVariablesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Topology() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::TopologyRequest, ::gateway_protocol::TopologyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::TopologyRequest* request, ::gateway_protocol::TopologyResponse* response) { return this->Topology(context, request, response); }));}
    void SetMessageAllocatorFor_Topology(
        ::grpc::MessageAllocator< ::gateway_protocol::TopologyRequest, ::gateway_protocol::TopologyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::TopologyRequest, ::gateway_protocol::TopologyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Topology() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Topology(::grpc::ServerContext* /*context*/, const ::gateway_protocol::TopologyRequest* /*request*/, ::gateway_protocol::TopologyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Topology(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::TopologyRequest* /*request*/, ::gateway_protocol::TopologyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateJobRetries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateJobRetries() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::UpdateJobRetriesRequest, ::gateway_protocol::UpdateJobRetriesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::UpdateJobRetriesRequest* request, ::gateway_protocol::UpdateJobRetriesResponse* response) { return this->UpdateJobRetries(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateJobRetries(
        ::grpc::MessageAllocator< ::gateway_protocol::UpdateJobRetriesRequest, ::gateway_protocol::UpdateJobRetriesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::UpdateJobRetriesRequest, ::gateway_protocol::UpdateJobRetriesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateJobRetries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateJobRetries(::grpc::ServerContext* /*context*/, const ::gateway_protocol::UpdateJobRetriesRequest* /*request*/, ::gateway_protocol::UpdateJobRetriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateJobRetries(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::UpdateJobRetriesRequest* /*request*/, ::gateway_protocol::UpdateJobRetriesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ModifyProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ModifyProcessInstance() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::ModifyProcessInstanceRequest, ::gateway_protocol::ModifyProcessInstanceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::gateway_protocol::ModifyProcessInstanceRequest* request, ::gateway_protocol::ModifyProcessInstanceResponse* response) { return this->ModifyProcessInstance(context, request, response); }));}
    void SetMessageAllocatorFor_ModifyProcessInstance(
        ::grpc::MessageAllocator< ::gateway_protocol::ModifyProcessInstanceRequest, ::gateway_protocol::ModifyProcessInstanceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::gateway_protocol::ModifyProcessInstanceRequest, ::gateway_protocol::ModifyProcessInstanceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ModifyProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ModifyProcessInstanceRequest* /*request*/, ::gateway_protocol::ModifyProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModifyProcessInstance(
      ::grpc::CallbackServerContext* /*context*/, const ::gateway_protocol::ModifyProcessInstanceRequest* /*request*/, ::gateway_protocol::ModifyProcessInstanceResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ActivateJobs<WithCallbackMethod_CancelProcessInstance<WithCallbackMethod_CompleteJob<WithCallbackMethod_CreateProcessInstance<WithCallbackMethod_CreateProcessInstanceWithResult<WithCallbackMethod_DeployProcess<WithCallbackMethod_DeployResource<WithCallbackMethod_FailJob<WithCallbackMethod_ThrowError<WithCallbackMethod_PublishMessage<WithCallbackMethod_ResolveIncident<WithCallbackMethod_SetVariables<WithCallbackMethod_Topology<WithCallbackMethod_UpdateJobRetries<WithCallbackMethod_ModifyProcessInstance<Service > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ActivateJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ActivateJobs() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ActivateJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateJobs(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ActivateJobsRequest* /*request*/, ::grpc::ServerWriter< ::gateway_protocol::ActivateJobsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelProcessInstance() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CancelProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CancelProcessInstanceRequest* /*request*/, ::gateway_protocol::CancelProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CompleteJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CompleteJob() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CompleteJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CompleteJobRequest* /*request*/, ::gateway_protocol::CompleteJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateProcessInstance() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_CreateProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateProcessInstanceWithResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateProcessInstanceWithResult() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CreateProcessInstanceWithResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstanceWithResult(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceWithResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeployProcess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeployProcess() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_DeployProcess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployProcess(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployProcessRequest* /*request*/, ::gateway_protocol::DeployProcessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeployResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeployResource() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeployResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployResource(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployResourceRequest* /*request*/, ::gateway_protocol::DeployResourceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FailJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FailJob() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_FailJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FailJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::FailJobRequest* /*request*/, ::gateway_protocol::FailJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ThrowError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ThrowError() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ThrowError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ThrowError(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ThrowErrorRequest* /*request*/, ::gateway_protocol::ThrowErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PublishMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PublishMessage() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_PublishMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishMessage(::grpc::ServerContext* /*context*/, const ::gateway_protocol::PublishMessageRequest* /*request*/, ::gateway_protocol::PublishMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResolveIncident : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResolveIncident() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ResolveIncident() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveIncident(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ResolveIncidentRequest* /*request*/, ::gateway_protocol::ResolveIncidentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVariables() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::gateway_protocol::SetVariablesRequest* /*request*/, ::gateway_protocol::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Topology() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_Topology() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Topology(::grpc::ServerContext* /*context*/, const ::gateway_protocol::TopologyRequest* /*request*/, ::gateway_protocol::TopologyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateJobRetries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateJobRetries() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_UpdateJobRetries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateJobRetries(::grpc::ServerContext* /*context*/, const ::gateway_protocol::UpdateJobRetriesRequest* /*request*/, ::gateway_protocol::UpdateJobRetriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ModifyProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ModifyProcessInstance() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ModifyProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ModifyProcessInstanceRequest* /*request*/, ::gateway_protocol::ModifyProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ActivateJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ActivateJobs() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ActivateJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateJobs(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ActivateJobsRequest* /*request*/, ::grpc::ServerWriter< ::gateway_protocol::ActivateJobsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActivateJobs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelProcessInstance() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CancelProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CancelProcessInstanceRequest* /*request*/, ::gateway_protocol::CancelProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelProcessInstance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CompleteJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CompleteJob() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_CompleteJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CompleteJobRequest* /*request*/, ::gateway_protocol::CompleteJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompleteJob(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateProcessInstance() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_CreateProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateProcessInstance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateProcessInstanceWithResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateProcessInstanceWithResult() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CreateProcessInstanceWithResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstanceWithResult(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceWithResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateProcessInstanceWithResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeployProcess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeployProcess() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_DeployProcess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployProcess(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployProcessRequest* /*request*/, ::gateway_protocol::DeployProcessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeployProcess(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeployResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeployResource() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeployResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployResource(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployResourceRequest* /*request*/, ::gateway_protocol::DeployResourceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeployResource(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FailJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FailJob() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_FailJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FailJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::FailJobRequest* /*request*/, ::gateway_protocol::FailJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFailJob(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ThrowError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ThrowError() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ThrowError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ThrowError(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ThrowErrorRequest* /*request*/, ::gateway_protocol::ThrowErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestThrowError(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PublishMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PublishMessage() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_PublishMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishMessage(::grpc::ServerContext* /*context*/, const ::gateway_protocol::PublishMessageRequest* /*request*/, ::gateway_protocol::PublishMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResolveIncident : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResolveIncident() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ResolveIncident() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveIncident(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ResolveIncidentRequest* /*request*/, ::gateway_protocol::ResolveIncidentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResolveIncident(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVariables() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::gateway_protocol::SetVariablesRequest* /*request*/, ::gateway_protocol::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Topology() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_Topology() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Topology(::grpc::ServerContext* /*context*/, const ::gateway_protocol::TopologyRequest* /*request*/, ::gateway_protocol::TopologyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTopology(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateJobRetries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateJobRetries() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_UpdateJobRetries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateJobRetries(::grpc::ServerContext* /*context*/, const ::gateway_protocol::UpdateJobRetriesRequest* /*request*/, ::gateway_protocol::UpdateJobRetriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateJobRetries(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ModifyProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ModifyProcessInstance() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ModifyProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ModifyProcessInstanceRequest* /*request*/, ::gateway_protocol::ModifyProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModifyProcessInstance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ActivateJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ActivateJobs() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->ActivateJobs(context, request); }));
    }
    ~WithRawCallbackMethod_ActivateJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateJobs(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ActivateJobsRequest* /*request*/, ::grpc::ServerWriter< ::gateway_protocol::ActivateJobsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ActivateJobs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CancelProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CancelProcessInstance() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelProcessInstance(context, request, response); }));
    }
    ~WithRawCallbackMethod_CancelProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CancelProcessInstanceRequest* /*request*/, ::gateway_protocol::CancelProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelProcessInstance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CompleteJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CompleteJob() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CompleteJob(context, request, response); }));
    }
    ~WithRawCallbackMethod_CompleteJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CompleteJobRequest* /*request*/, ::gateway_protocol::CompleteJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CompleteJob(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateProcessInstance() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateProcessInstance(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateProcessInstance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateProcessInstanceWithResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateProcessInstanceWithResult() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateProcessInstanceWithResult(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateProcessInstanceWithResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateProcessInstanceWithResult(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceWithResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateProcessInstanceWithResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeployProcess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeployProcess() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeployProcess(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeployProcess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployProcess(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployProcessRequest* /*request*/, ::gateway_protocol::DeployProcessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeployProcess(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeployResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeployResource() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeployResource(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeployResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeployResource(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployResourceRequest* /*request*/, ::gateway_protocol::DeployResourceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeployResource(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FailJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FailJob() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FailJob(context, request, response); }));
    }
    ~WithRawCallbackMethod_FailJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FailJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::FailJobRequest* /*request*/, ::gateway_protocol::FailJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FailJob(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ThrowError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ThrowError() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ThrowError(context, request, response); }));
    }
    ~WithRawCallbackMethod_ThrowError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ThrowError(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ThrowErrorRequest* /*request*/, ::gateway_protocol::ThrowErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ThrowError(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PublishMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PublishMessage() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PublishMessage(context, request, response); }));
    }
    ~WithRawCallbackMethod_PublishMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishMessage(::grpc::ServerContext* /*context*/, const ::gateway_protocol::PublishMessageRequest* /*request*/, ::gateway_protocol::PublishMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PublishMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResolveIncident : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResolveIncident() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResolveIncident(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResolveIncident() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveIncident(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ResolveIncidentRequest* /*request*/, ::gateway_protocol::ResolveIncidentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResolveIncident(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetVariables() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVariables(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::gateway_protocol::SetVariablesRequest* /*request*/, ::gateway_protocol::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Topology() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Topology(context, request, response); }));
    }
    ~WithRawCallbackMethod_Topology() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Topology(::grpc::ServerContext* /*context*/, const ::gateway_protocol::TopologyRequest* /*request*/, ::gateway_protocol::TopologyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Topology(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateJobRetries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateJobRetries() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateJobRetries(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateJobRetries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateJobRetries(::grpc::ServerContext* /*context*/, const ::gateway_protocol::UpdateJobRetriesRequest* /*request*/, ::gateway_protocol::UpdateJobRetriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateJobRetries(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ModifyProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ModifyProcessInstance() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ModifyProcessInstance(context, request, response); }));
    }
    ~WithRawCallbackMethod_ModifyProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ModifyProcessInstanceRequest* /*request*/, ::gateway_protocol::ModifyProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModifyProcessInstance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelProcessInstance() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::CancelProcessInstanceRequest, ::gateway_protocol::CancelProcessInstanceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::CancelProcessInstanceRequest, ::gateway_protocol::CancelProcessInstanceResponse>* streamer) {
                       return this->StreamedCancelProcessInstance(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CancelProcessInstanceRequest* /*request*/, ::gateway_protocol::CancelProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelProcessInstance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::CancelProcessInstanceRequest,::gateway_protocol::CancelProcessInstanceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CompleteJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CompleteJob() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::CompleteJobRequest, ::gateway_protocol::CompleteJobResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::CompleteJobRequest, ::gateway_protocol::CompleteJobResponse>* streamer) {
                       return this->StreamedCompleteJob(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CompleteJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CompleteJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CompleteJobRequest* /*request*/, ::gateway_protocol::CompleteJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCompleteJob(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::CompleteJobRequest,::gateway_protocol::CompleteJobResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateProcessInstance() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::CreateProcessInstanceRequest, ::gateway_protocol::CreateProcessInstanceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::CreateProcessInstanceRequest, ::gateway_protocol::CreateProcessInstanceResponse>* streamer) {
                       return this->StreamedCreateProcessInstance(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateProcessInstance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::CreateProcessInstanceRequest,::gateway_protocol::CreateProcessInstanceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateProcessInstanceWithResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateProcessInstanceWithResult() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::CreateProcessInstanceWithResultRequest, ::gateway_protocol::CreateProcessInstanceWithResultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::CreateProcessInstanceWithResultRequest, ::gateway_protocol::CreateProcessInstanceWithResultResponse>* streamer) {
                       return this->StreamedCreateProcessInstanceWithResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateProcessInstanceWithResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateProcessInstanceWithResult(::grpc::ServerContext* /*context*/, const ::gateway_protocol::CreateProcessInstanceWithResultRequest* /*request*/, ::gateway_protocol::CreateProcessInstanceWithResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateProcessInstanceWithResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::CreateProcessInstanceWithResultRequest,::gateway_protocol::CreateProcessInstanceWithResultResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeployProcess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeployProcess() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::DeployProcessRequest, ::gateway_protocol::DeployProcessResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::DeployProcessRequest, ::gateway_protocol::DeployProcessResponse>* streamer) {
                       return this->StreamedDeployProcess(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeployProcess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeployProcess(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployProcessRequest* /*request*/, ::gateway_protocol::DeployProcessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeployProcess(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::DeployProcessRequest,::gateway_protocol::DeployProcessResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeployResource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeployResource() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::DeployResourceRequest, ::gateway_protocol::DeployResourceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::DeployResourceRequest, ::gateway_protocol::DeployResourceResponse>* streamer) {
                       return this->StreamedDeployResource(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeployResource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeployResource(::grpc::ServerContext* /*context*/, const ::gateway_protocol::DeployResourceRequest* /*request*/, ::gateway_protocol::DeployResourceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeployResource(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::DeployResourceRequest,::gateway_protocol::DeployResourceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FailJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FailJob() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::FailJobRequest, ::gateway_protocol::FailJobResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::FailJobRequest, ::gateway_protocol::FailJobResponse>* streamer) {
                       return this->StreamedFailJob(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FailJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FailJob(::grpc::ServerContext* /*context*/, const ::gateway_protocol::FailJobRequest* /*request*/, ::gateway_protocol::FailJobResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFailJob(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::FailJobRequest,::gateway_protocol::FailJobResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ThrowError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ThrowError() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::ThrowErrorRequest, ::gateway_protocol::ThrowErrorResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::ThrowErrorRequest, ::gateway_protocol::ThrowErrorResponse>* streamer) {
                       return this->StreamedThrowError(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ThrowError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ThrowError(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ThrowErrorRequest* /*request*/, ::gateway_protocol::ThrowErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedThrowError(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::ThrowErrorRequest,::gateway_protocol::ThrowErrorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PublishMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PublishMessage() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::PublishMessageRequest, ::gateway_protocol::PublishMessageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::PublishMessageRequest, ::gateway_protocol::PublishMessageResponse>* streamer) {
                       return this->StreamedPublishMessage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PublishMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PublishMessage(::grpc::ServerContext* /*context*/, const ::gateway_protocol::PublishMessageRequest* /*request*/, ::gateway_protocol::PublishMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPublishMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::PublishMessageRequest,::gateway_protocol::PublishMessageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResolveIncident : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResolveIncident() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::ResolveIncidentRequest, ::gateway_protocol::ResolveIncidentResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::ResolveIncidentRequest, ::gateway_protocol::ResolveIncidentResponse>* streamer) {
                       return this->StreamedResolveIncident(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResolveIncident() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResolveIncident(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ResolveIncidentRequest* /*request*/, ::gateway_protocol::ResolveIncidentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResolveIncident(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::ResolveIncidentRequest,::gateway_protocol::ResolveIncidentResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVariables() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::SetVariablesRequest, ::gateway_protocol::SetVariablesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::SetVariablesRequest, ::gateway_protocol::SetVariablesResponse>* streamer) {
                       return this->StreamedSetVariables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::gateway_protocol::SetVariablesRequest* /*request*/, ::gateway_protocol::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVariables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::SetVariablesRequest,::gateway_protocol::SetVariablesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Topology : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Topology() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::TopologyRequest, ::gateway_protocol::TopologyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::TopologyRequest, ::gateway_protocol::TopologyResponse>* streamer) {
                       return this->StreamedTopology(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Topology() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Topology(::grpc::ServerContext* /*context*/, const ::gateway_protocol::TopologyRequest* /*request*/, ::gateway_protocol::TopologyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTopology(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::TopologyRequest,::gateway_protocol::TopologyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateJobRetries : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateJobRetries() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::UpdateJobRetriesRequest, ::gateway_protocol::UpdateJobRetriesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::UpdateJobRetriesRequest, ::gateway_protocol::UpdateJobRetriesResponse>* streamer) {
                       return this->StreamedUpdateJobRetries(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateJobRetries() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateJobRetries(::grpc::ServerContext* /*context*/, const ::gateway_protocol::UpdateJobRetriesRequest* /*request*/, ::gateway_protocol::UpdateJobRetriesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateJobRetries(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::UpdateJobRetriesRequest,::gateway_protocol::UpdateJobRetriesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ModifyProcessInstance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ModifyProcessInstance() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::gateway_protocol::ModifyProcessInstanceRequest, ::gateway_protocol::ModifyProcessInstanceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::gateway_protocol::ModifyProcessInstanceRequest, ::gateway_protocol::ModifyProcessInstanceResponse>* streamer) {
                       return this->StreamedModifyProcessInstance(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ModifyProcessInstance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ModifyProcessInstance(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ModifyProcessInstanceRequest* /*request*/, ::gateway_protocol::ModifyProcessInstanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedModifyProcessInstance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::gateway_protocol::ModifyProcessInstanceRequest,::gateway_protocol::ModifyProcessInstanceResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CancelProcessInstance<WithStreamedUnaryMethod_CompleteJob<WithStreamedUnaryMethod_CreateProcessInstance<WithStreamedUnaryMethod_CreateProcessInstanceWithResult<WithStreamedUnaryMethod_DeployProcess<WithStreamedUnaryMethod_DeployResource<WithStreamedUnaryMethod_FailJob<WithStreamedUnaryMethod_ThrowError<WithStreamedUnaryMethod_PublishMessage<WithStreamedUnaryMethod_ResolveIncident<WithStreamedUnaryMethod_SetVariables<WithStreamedUnaryMethod_Topology<WithStreamedUnaryMethod_UpdateJobRetries<WithStreamedUnaryMethod_ModifyProcessInstance<Service > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_ActivateJobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ActivateJobs() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::gateway_protocol::ActivateJobsRequest, ::gateway_protocol::ActivateJobsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::gateway_protocol::ActivateJobsRequest, ::gateway_protocol::ActivateJobsResponse>* streamer) {
                       return this->StreamedActivateJobs(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ActivateJobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ActivateJobs(::grpc::ServerContext* /*context*/, const ::gateway_protocol::ActivateJobsRequest* /*request*/, ::grpc::ServerWriter< ::gateway_protocol::ActivateJobsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedActivateJobs(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::gateway_protocol::ActivateJobsRequest,::gateway_protocol::ActivateJobsResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_ActivateJobs<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_ActivateJobs<WithStreamedUnaryMethod_CancelProcessInstance<WithStreamedUnaryMethod_CompleteJob<WithStreamedUnaryMethod_CreateProcessInstance<WithStreamedUnaryMethod_CreateProcessInstanceWithResult<WithStreamedUnaryMethod_DeployProcess<WithStreamedUnaryMethod_DeployResource<WithStreamedUnaryMethod_FailJob<WithStreamedUnaryMethod_ThrowError<WithStreamedUnaryMethod_PublishMessage<WithStreamedUnaryMethod_ResolveIncident<WithStreamedUnaryMethod_SetVariables<WithStreamedUnaryMethod_Topology<WithStreamedUnaryMethod_UpdateJobRetries<WithStreamedUnaryMethod_ModifyProcessInstance<Service > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace gateway_protocol


#endif  // GRPC_gateway_2eproto__INCLUDED
